{"ast":null,"code":"import { getOppositeColor } from \"../utils/colors\";\nexport let FigureNames;\n\n(function (FigureNames) {\n  FigureNames[\"FIGURE\"] = \"Figure\";\n  FigureNames[\"PAWN\"] = \"Pawn\";\n  FigureNames[\"ROOK\"] = \"Rook\";\n  FigureNames[\"KNIGHT\"] = \"Knight\";\n  FigureNames[\"BISHOP\"] = \"Bishop\";\n  FigureNames[\"QUEEN\"] = \"Queen\";\n  FigureNames[\"KING\"] = \"King\";\n})(FigureNames || (FigureNames = {}));\n\nexport class Figure {\n  constructor(color, cell) {\n    this.color = void 0;\n    this.logo = void 0;\n    this.cell = void 0;\n    this.name = void 0;\n    this.id = void 0;\n    this.color = color;\n    this.cell = cell;\n    this.cell.figure = this;\n    this.logo = null;\n    this.name = FigureNames.FIGURE;\n    this.id = Math.random();\n  }\n\n  getBoard() {\n    return this.cell.board;\n  }\n\n  canMove(target) {\n    var _target$figure;\n\n    if (((_target$figure = target.figure) === null || _target$figure === void 0 ? void 0 : _target$figure.color) === this.color) {\n      return false;\n    }\n\n    if (!this.isSafeMove(target)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  moveFigure() {// pass\n  }\n\n  canAttackKing() {\n    const board = this.getBoard();\n\n    for (let i = 0; i < board.cells.length; i += 1) {\n      const row = board.cells[i];\n\n      for (let j = 0; j < row.length; j += 1) {\n        var _target$figure2;\n\n        const target = row[j];\n\n        if (this.canMove(target) && ((_target$figure2 = target.figure) === null || _target$figure2 === void 0 ? void 0 : _target$figure2.name) === FigureNames.KING) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  isSafeMove(target) {\n    console.log('call');\n    const board = this.getBoard();\n\n    if (!board.colorUnderShah) {\n      return true;\n    } // Virtual move figure to target\n\n\n    const tmpTargetFigure = target.figure;\n    target.figure = this;\n    const oppositeColor = getOppositeColor(this.color);\n    const enemyCells = board.getCellsWithFigures(oppositeColor); // console.log(enemyCells)\n\n    for (let i = 0; i < enemyCells.length; i += 1) {\n      var _enemyCell$figure;\n\n      const enemyCell = enemyCells[i];\n\n      if (enemyCell !== null && enemyCell !== void 0 && (_enemyCell$figure = enemyCell.figure) !== null && _enemyCell$figure !== void 0 && _enemyCell$figure.canAttackKing()) {\n        return false;\n      }\n    }\n\n    target.figure = tmpTargetFigure;\n    return true;\n  }\n\n}","map":{"version":3,"names":["getOppositeColor","FigureNames","Figure","constructor","color","cell","logo","name","id","figure","FIGURE","Math","random","getBoard","board","canMove","target","isSafeMove","moveFigure","canAttackKing","i","cells","length","row","j","KING","console","log","colorUnderShah","tmpTargetFigure","oppositeColor","enemyCells","getCellsWithFigures","enemyCell"],"sources":["/Users/alextsukanov/my-projects/chess/src/models/figure.ts"],"sourcesContent":["import { Colors } from \"./colors\";\nimport logo from '../assets/black-king.png';\nimport { Cell } from \"./cell\";\nimport { Board } from \"./board\";\nimport { getOppositeColor } from \"../utils/colors\";\n\nexport enum FigureNames {\n    FIGURE = 'Figure',\n    PAWN = 'Pawn',\n    ROOK = 'Rook',\n    KNIGHT = 'Knight',\n    BISHOP = 'Bishop',\n    QUEEN = 'Queen',\n    KING = 'King',\n}\n\nexport class Figure {\n    color: Colors;\n    logo: typeof logo | null;\n    cell: Cell;\n    name: FigureNames;\n    id: number;\n\n    constructor(color: Colors, cell: Cell) {\n        this.color = color;\n        this.cell = cell;\n        this.cell.figure = this;\n\n        this.logo = null;\n        this.name = FigureNames.FIGURE;\n        this.id = Math.random();\n    }\n\n    private getBoard(): Board {\n        return this.cell.board;\n    }\n\n    public canMove(target: Cell): boolean {\n        if (target.figure?.color === this.color) {\n            return false;\n        }\n\n        if (!this.isSafeMove(target)) {\n            return false;\n        }\n        \n        return true;\n    }\n\n    public moveFigure() {\n        // pass\n    }\n\n    public canAttackKing(): boolean {\n        const board = this.getBoard();\n\n        for (let i = 0; i < board.cells.length; i += 1) {\n            const row = board.cells[i];\n\n            for (let j = 0; j < row.length; j += 1) {\n                const target = row[j];\n\n                if (this.canMove(target) && target.figure?.name === FigureNames.KING) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    private isSafeMove(target: Cell): boolean {\n        console.log('call')\n        const board = this.getBoard();\n\n        if (!board.colorUnderShah) {\n            return true;\n        }\n        \n        // Virtual move figure to target\n        const tmpTargetFigure = target.figure;\n        target.figure = this;\n\n        const oppositeColor = getOppositeColor(this.color);\n        const enemyCells = board.getCellsWithFigures(oppositeColor);\n        // console.log(enemyCells)\n\n        for (let i = 0; i < enemyCells.length; i += 1) {\n            const enemyCell = enemyCells[i];\n\n            if (enemyCell?.figure?.canAttackKing()) {\n                return false;\n            }\n        }\n\n        target.figure = tmpTargetFigure;\n\n        return true;\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}