{"ast":null,"code":"import { getOppositeColor } from \"../utils/colors\";\nexport let FigureNames;\n\n(function (FigureNames) {\n  FigureNames[\"FIGURE\"] = \"Figure\";\n  FigureNames[\"PAWN\"] = \"Pawn\";\n  FigureNames[\"ROOK\"] = \"Rook\";\n  FigureNames[\"KNIGHT\"] = \"Knight\";\n  FigureNames[\"BISHOP\"] = \"Bishop\";\n  FigureNames[\"QUEEN\"] = \"Queen\";\n  FigureNames[\"KING\"] = \"King\";\n})(FigureNames || (FigureNames = {}));\n\nexport class Figure {\n  constructor(color, cell) {\n    this.color = void 0;\n    this.logo = void 0;\n    this.cell = void 0;\n    this.name = void 0;\n    this.id = void 0;\n    this.color = color;\n    this.cell = cell;\n    this.cell.figure = this;\n    this.logo = null;\n    this.name = FigureNames.FIGURE;\n    this.id = Math.random();\n  }\n\n  getBoard() {\n    return this.cell.board;\n  }\n\n  canMove(target) {\n    var _target$figure;\n\n    if (((_target$figure = target.figure) === null || _target$figure === void 0 ? void 0 : _target$figure.color) === this.color) {\n      return false;\n    } // if (!this.isSafeMove(target)) {\n    //     return false;\n    // }\n\n\n    return true;\n  }\n\n  moveFigure() {// pass\n  }\n\n  canAttackKing() {\n    const board = this.getBoard();\n\n    for (let i = 0; i < board.cells.length; i += 1) {\n      const row = board.cells[i];\n\n      for (let j = 0; j < row.length; j += 1) {\n        var _target$figure2;\n\n        const target = row[j];\n\n        if (this.canMove(target) && ((_target$figure2 = target.figure) === null || _target$figure2 === void 0 ? void 0 : _target$figure2.name) === FigureNames.KING) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  isSafeMove(target) {\n    const board = this.getBoard();\n\n    if (!board.colorUnderShah) {\n      return true;\n    } // Virtual move figure to target\n\n\n    const tmpTargetFigure = target.figure;\n    console.log(tmpTargetFigure, '<=, tmpTargetFigure');\n    target.figure = this;\n    const oppositeColor = getOppositeColor(this.color);\n    const enemyFigures = board.getFigures(oppositeColor); // console.log(enemyCells)\n\n    for (let i = 0; i < enemyFigures.length; i += 1) {\n      var _enemyCell$figure;\n\n      const enemyCell = enemyFigures[i];\n\n      if (enemyCell !== null && enemyCell !== void 0 && (_enemyCell$figure = enemyCell.figure) !== null && _enemyCell$figure !== void 0 && _enemyCell$figure.canAttackKing()) {\n        target.figure = tmpTargetFigure;\n        return false;\n      }\n    }\n\n    target.figure = tmpTargetFigure;\n    console.log(target.figure, '<=, tmpTargetFigure');\n    return true;\n  }\n\n}","map":{"version":3,"names":["getOppositeColor","FigureNames","Figure","constructor","color","cell","logo","name","id","figure","FIGURE","Math","random","getBoard","board","canMove","target","moveFigure","canAttackKing","i","cells","length","row","j","KING","isSafeMove","colorUnderShah","tmpTargetFigure","console","log","oppositeColor","enemyFigures","getFigures","enemyCell"],"sources":["/Users/alextsukanov/my-projects/chess/src/models/figure.ts"],"sourcesContent":["import { Colors } from \"./colors\";\nimport logo from '../assets/black-king.png';\nimport { Cell } from \"./cell\";\nimport { Board } from \"./board\";\nimport { getOppositeColor } from \"../utils/colors\";\n\nexport enum FigureNames {\n    FIGURE = 'Figure',\n    PAWN = 'Pawn',\n    ROOK = 'Rook',\n    KNIGHT = 'Knight',\n    BISHOP = 'Bishop',\n    QUEEN = 'Queen',\n    KING = 'King',\n}\n\nexport class Figure {\n    color: Colors;\n    logo: typeof logo | null;\n    cell: Cell;\n    name: FigureNames;\n    id: number;\n\n    constructor(color: Colors, cell: Cell) {\n        this.color = color;\n        this.cell = cell;\n        this.cell.figure = this;\n\n        this.logo = null;\n        this.name = FigureNames.FIGURE;\n        this.id = Math.random();\n    }\n\n    private getBoard(): Board {\n        return this.cell.board;\n    }\n\n    public canMove(target: Cell): boolean {\n        if (target.figure?.color === this.color) {\n            return false;\n        }\n\n        // if (!this.isSafeMove(target)) {\n        //     return false;\n        // }\n        \n        return true;\n    }\n\n    public moveFigure() {\n        // pass\n    }\n\n    public canAttackKing(): boolean {\n        const board = this.getBoard();\n\n        for (let i = 0; i < board.cells.length; i += 1) {\n            const row = board.cells[i];\n\n            for (let j = 0; j < row.length; j += 1) {\n                const target = row[j];\n\n                if (this.canMove(target) && target.figure?.name === FigureNames.KING) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    public isSafeMove(target: Cell): boolean {\n        const board = this.getBoard();\n\n        if (!board.colorUnderShah) {\n            return true;\n        }\n        \n        // Virtual move figure to target\n        const tmpTargetFigure = target.figure;\n        console.log(tmpTargetFigure, '<=, tmpTargetFigure')\n        target.figure = this;\n\n        const oppositeColor = getOppositeColor(this.color);\n        const enemyFigures = board.getFigures(oppositeColor);\n        // console.log(enemyCells)\n\n        for (let i = 0; i < enemyFigures.length; i += 1) {\n            const enemyCell = enemyFigures[i];\n\n            if (enemyCell?.figure?.canAttackKing()) {\n                target.figure = tmpTargetFigure;\n                return false;\n            }\n        }\n\n        target.figure = tmpTargetFigure;\n        console.log(target.figure, '<=, tmpTargetFigure')\n\n        return true;\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}